Got it ğŸ‘ Youâ€™re asking about **TC (Time Complexity)** and **SC (Space Complexity)** in **C++**.
Letâ€™s go step by step with **deep detail** so you understand how to analyze any program.

---

# ğŸ”¹ 1. What is Time Complexity (TC)?

Time Complexity measures **how the runtime of a program grows** with the size of the input `n`.
It ignores machine speed and focuses on the number of **basic operations** (comparisons, assignments, function calls, etc.).

ğŸ‘‰ Think of it as:
**â€œHow does the running time scale if input becomes very large?â€**

### Example 1: Constant Time â€“ `O(1)`

```cpp
int getFirstElement(vector<int>& arr) {
    return arr[0]; // Just one access
}
```

âœ… Always **1 operation** â†’ `O(1)`.

---

### Example 2: Linear Time â€“ `O(n)`

```cpp
int sumArray(vector<int>& arr) {
    int sum = 0;
    for (int x : arr) {   // loop runs n times
        sum += x;
    }
    return sum;
}
```

âœ… Loop runs `n` times â†’ Time = proportional to `n`.

---

### Example 3: Quadratic Time â€“ `O(n^2)`

```cpp
void printPairs(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n; i++) {         // n times
        for (int j = 0; j < n; j++) {     // n times
            cout << arr[i] << ", " << arr[j] << endl;
        }
    }
}
```

âœ… Nested loop â†’ `n * n = n^2` â†’ `O(n^2)`.

---

### Example 4: Logarithmic Time â€“ `O(log n)`

```cpp
int binarySearch(vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}
```

âœ… Each step halves the array â†’ about `logâ‚‚(n)` steps.

---

### Common Time Complexities in C++

* **O(1)** â†’ Constant time (array access, hash map insert)
* **O(log n)** â†’ Binary search, balanced BST search
* **O(n)** â†’ Linear scan, traversing an array
* **O(n log n)** â†’ Merge Sort, QuickSort (average), HeapSort
* **O(nÂ²)** â†’ Bubble Sort, Insertion Sort (worst case)
* **O(2^n)** â†’ Recursive Fibonacci without DP
* **O(n!)** â†’ Traveling Salesman brute force

---

# ğŸ”¹ 2. What is Space Complexity (SC)?

Space Complexity measures **how much memory** a program uses depending on input size `n`.

ğŸ‘‰ It includes:

1. **Fixed Part** â†’ Constants, program instructions, variables (`int x`, `char c`).
2. **Variable Part** â†’ Depends on input (`n` sized arrays, recursion stack, dynamic allocations).

---

### Example 1: Constant Space â€“ `O(1)`

```cpp
int sum(vector<int>& arr) {
    int total = 0;  // fixed space
    for (int x : arr) {
        total += x;
    }
    return total;
}
```

âœ… Uses only `total` + loop variable â†’ **constant space**.

---

### Example 2: Linear Space â€“ `O(n)`

```cpp
vector<int> copyArray(vector<int>& arr) {
    vector<int> newArr(arr.size());
    for (int i = 0; i < arr.size(); i++) {
        newArr[i] = arr[i];
    }
    return newArr;
}
```

âœ… Extra array of size `n` â†’ Space = `O(n)`.

---

### Example 3: Recursive Calls â€“ `O(n)`

```cpp
int factorial(int n) {
    if (n == 0) return 1;
    return n * factorial(n - 1);
}
```

âœ… Recursion stack depth = `n` â†’ Space = `O(n)`.

---

### Example 4: Logarithmic Space â€“ `O(log n)`

```cpp
int binarySearchRecursive(vector<int>& arr, int low, int high, int target) {
    if (low > high) return -1;
    int mid = (low + high) / 2;
    if (arr[mid] == target) return mid;
    else if (arr[mid] < target) return binarySearchRecursive(arr, mid + 1, high, target);
    else return binarySearchRecursive(arr, low, mid - 1, target);
}
```

âœ… Recursion depth = `log n` â†’ Space = `O(log n)`.

---

# ğŸ”¹ 3. How to Analyze TC & SC in C++

### Steps:

1. **Find input size (`n`)** â†’ number of elements, string length, graph nodes, etc.
2. **Count loops & recursions**:

   * Single loop â†’ `O(n)`
   * Nested loops â†’ multiply (`O(nÂ²)`)
   * Divide and conquer â†’ `O(log n)`
3. **Consider auxiliary space**:

   * Arrays, vectors, hash maps, recursion stack.

---

# ğŸ”¹ 4. Quick Comparison Table

| Operation              | Time Complexity             | Space Complexity           |
| ---------------------- | --------------------------- | -------------------------- |
| Array access           | O(1)                        | O(1)                       |
| Traversing array       | O(n)                        | O(1)                       |
| Merge Sort             | O(n log n)                  | O(n)                       |
| Quick Sort             | O(n log n) avg, O(nÂ²) worst | O(log n) (recursion stack) |
| Hash map insert/search | O(1) avg, O(n) worst        | O(n)                       |
| BFS/DFS in graph       | O(V+E)                      | O(V)                       |

---

âœ… In short:

* **TC tells us how fast a program runs.**
* **SC tells us how much memory it consumes.**

---

Do you want me to also create a **cheat sheet of common C++ STL operations (like vector, map, unordered\_map, set) with their TC & SC**? That will help a lot for interviews like Google.

    0 1 2 3 4
i=0 3 3 3 3 3 
i=1 3 2 2 2 3 j-1 
i=2 3 2 1 2 3 
i=3 3 2 2 2 3 
i=4 3 3 3 3 3
